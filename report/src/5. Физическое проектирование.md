# Физическое проектирование

## Обоснование выбора конкретной СУБД

В качестве системы управления базами данных (СУБД) для реализации проекта была выбрана PostgreSQL. Этот выбор обоснован рядом факторов:

- PostgreSQL — это мощная объектно-реляционная СУБД с открытым исходным кодом, которая поддерживает расширенные возможности SQL и соответствует стандартам.
- Система обладает высокой производительностью и эффективной планировкой запросов, что важно при работе с большим объемом данных и сложными связями между таблицами.
- PostgreSQL широко используется в индустрии и хорошо поддерживается сообществом, что обеспечивает доступность документации, инструментов и решений типовых задач.
- Также немаловажным преимуществом является наличие встроенной поддержки пользовательских типов, таких как перечисления (ENUM), которые активно применяются в данной базе данных.
- Наконец, PostgreSQL хорошо интегрируется с Python через библиотеки psycopg и SQLAlchemy, что важно на этапе генерации и заполнения данных.

Таким образом, PostgreSQL является оптимальным выбором как с технической, так и с практической точек зрения.

## Создание базы данных

Создание и запуск базы данных производится с использованием среды контейнеризации Docker. Это позволяет упростить настройку окружения, добиться воспроизводимости конфигурации и обеспечить удобство развертывания.

Для запуска PostgreSQL используется официальный образ postgres, настраиваемый через docker-compose. Все параметры подключения (имя пользователя, пароль, имя базы данных и порт) передаются через файл .env, что обеспечивает гибкость и безопасность конфигурации.

Для работы с базой и отслеживания её состояния применяется PGAdmin, также запускаемый как отдельный контейнер. Он позволяет удобно просматривать содержимое таблиц, выполнять SQL-запросы и отслеживать структуру базы данных через графический интерфейс.

Создание таблиц производится автоматически при старте контейнера с помощью специального SQL-файла schema.sql, который монтируется в контейнер базы данных и исполняется через docker-entrypoint-initdb.d. Эта схема позволяет без участия пользователя разворачивать структуру БД при первом запуске.

Таким образом, вся инфраструктура для базы данных развернута в виде контейнеров, а структура таблиц автоматически формируется при старте, что делает процесс развертывания гибким и надежным.

## Создание таблиц

Создание таблиц производилось с помощью инициирующего SQL-запроса schema.sql, исполняющегося через docker-entrypoint-initdb.d. Код для создания всех таблиц вынесен в [приложение](#lst:create-1).

## Заполнение таблиц. ETL-процессы загрузки базы данных

Заполнение базы данных проводилось в несколько этапов с использованием различных источников и инструментов, в зависимости от характера данных.

\noindent 1. Источники данных

Для так называемых статических сущностей — то есть данных, которые либо редко изменяются, либо представляют собой заранее известные справочники, были использованы как реальные источники, так и логически обоснованные предположения:

- Данные о предпочтениях пользователей, категориях предпочтений и стоимости меню были заимствованы из существующего сервиса по доставке здорового питания [GrowFood](http://growfood.pro).
- Информация о типах ингредиентов, блюдах и их составе формировалась на основе анализа ассортимента типовых рационов здорового питания, а также общих гастрономических принципов. Эти данные предварительно подготавливались в виде CSV-файлов и импортировались в базу.

\noindent 2. Генерация и вставка данных

\noindent Остальные сущности, в том числе:

- Пользователи,
- Курьеры,
- Заказы,
- Платёжные методы,
- Поставщики и поставки,

\noindent генерировались программно с использованием библиотеки [Faker (ru_RU)](https://fakerjs.dev), обеспечивающей реалистичные русскоязычные данные (имена, адреса, даты рождения и т.д.).

Для этого были реализованы Python-скрипты, которые подключаются к базе данных с помощью библиотеки [psycopg2](https://www.psycopg.org/docs/). Скрипты построены по модульному принципу: каждая таблица имеет собственный скрипт-загрузчик (seeder), а главный модуль запускает заполнение в нужной последовательности, учитывая зависимости между таблицами (например, сначала пользователи — затем заказы).

Код для Python-скриптов вынесен в [приложение](#lst:seeding-1)

После выполнения всех функций заполнения базы данных были получены заполненные таблицы, проиллюстрированные в [приложении](#fig:filled-1)

## Запросы в терминах SQL

1. Найти выручку сервиса за последний месяц. [Код запроса](#lst:query-1), [результат выполнения](#fig:query-1).
2. Какая доля (в `%`) общей выручки приходится на меню с названием «Похудение»? Проценты округлить до двух знаков после запятой. [Код запроса](#lst:query-2), [результат выполнения](#fig:query-2).
3. Вычислить НДС каждого меню и рассчитать цену каждого меню не включая НДС. Вывести название меню, его текущую цену, НДС и цену без НДС. Значения округлить до двух знаков после запятой. [Код запроса](#lst:query-3), [результат выполнения](#fig:query-3).
4. Найти заказы, которые оказались возвращены и были оплачены с помощью «Яндекс.Сплит». Вывести `id` заказа, дату заказа и реквизиты платежа. [Код запроса](#lst:query-4), [результат выполнения](#fig:query-4).
5. Найти топ-5 пользователей по количеству бонусов, которые большинство своих заказов оплатили наличными курьеру. Вывести `id` пользователя, его имя и количество бонусов. [Код запроса](#lst:query-5), [результат выполнения](#fig:query-5).
6. Найти блюда, содержащие хотя бы один ингредиент, который относится к самой популярной категории предпочтений. Вывести только названия блюд, отсортированные в алфавитном порядке. [Код запроса](#lst:query-6), [результат выполнения](#fig:query-6).
7. Вывести 2 строки с названием меню, массивом входящих в него блюд и даты, которые принесут больше всего прибыли (численно и в % относительно себестоимости). [Код запроса](#lst:query-7), [результат выполнения](#fig:query-7).

Пусть блюдо состоит из ингридиентов $x_1, x_2, \ldots, x_n$. Закупочная стоимость каждого ингридиента равна $c_1, c_2, \ldots, c_n$ соответственно. Тогда я предполагаю, что себестоимость блюда равна $p = \sum_{i=1}^n c_i$ (я не учитываю, что блюдо содержит $a$ грамм данного ингридиента).

Пусть меню на конкретный день состоит из блюд $y_1, y_2, \ldots, y_m$. Тогда себестоимость меню будет равна $P = \sum_{j=1}^m p_j$.

Розничная цена на данное меню равна $S$. Тогда прибыль от данного меню равна $S - P$. Будем находить 2 меню: с наибольшим значением $S - P$ и с наибольшим значением $\frac{S - P}{P}$.

Заметим, что цена ингредиента указана в долларах, а цена меню в рублях. Поэтому для вычисления прибыли нужно умножить цену ингредиента на курс доллара. Курс доллара принять равным 1 доллар = 7.55 рублей (поправка на нереалистичную заполненность базы данных и предположение о составе блюда).

8. Какие пары блюд находятся вместе в меню чаще всего? Вывести их названия и количество нахождений вместе. [Код запроса](#lst:query-8), [результат выполнения](#fig:query-8).
9.  Найти медианное количество заказов у пользователей. [Код запроса](#lst:query-9), [результат выполнения](#fig:query-9).

Если количество строк чётное, то медиана - это среднее двух средних значений. Если количество строк нечётное, то медиана - это значение в середине.

Если всего строк чётное количество, то `total_rows / 2` и `total_rows / 2 + 1` - целые числа, на выходе будет две строки и среднее арифметическое возьмётся от двух значений.

Если всего строк нечётное количество, то `total_rows / 2` и `total_rows / 2 + 1` - нецелые числа, на выходе будет одна строка и это и будет медиана. 

10. Рассчитать ежедневную выручку сервиса, рассчитать ежедневный прирост выручки (численно и в %) относительно предыдущего дня. [Код запроса](#lst:query-10), [результат выполнения](#fig:query-10).
11. Построить иерархию приглашенных и пригласивших пользователей. [Код запроса](#lst:query-11), [результат выполнения](#fig:query-11).
12. Пусть сегодня 1 число какого-то месяца. У нас есть список заказов за предыдущий месяц. В предположении, что количество заказов на каждую позицию в меню останется таким же, вывести список ингредиентов, для которых следует нанять ещё поставщиков (которых не хватит для изготовления нужных блюд на ближайший месяц). Рассчитывать со следующим допущением: если блюдо весит $a$ грамм и для его изготовления нужно $n$ ингредиентов, то каждого ингредиента нужно в количестве $\frac{a}{n}$ грамм. [Код запроса](#lst:query-12), [результат выполнения](#fig:query-12).

## Оценка размеров базы данных и каждого из файлов

```{=latex}
\begin{adjustbox}{max width=.99\linewidth}
\begin{tabular}{|c|l|l|c|c|c|c|}
\hline
\textbf{Отношение} & \textbf{Атрибут} & \textbf{Тип данных} & \textbf{Размер, байт} & \textbf{Среднее количество} & \textbf{Объем, байт} & \textbf{Объём, МБ} \\
\hline

\multirow{10}{*}{users}
& id & integer & 4 & \multirow{10}{*}{10000} & \multirow{10}{*}{1687552} &  \multirow{10}{*}{1.61}\\
& sex & gender & 4 & & \\
& birth\_date & date & 4 & & \\
& invited\_by\_id & integer & 4 & & \\
& bonuses & integer & 4 & & \\
& address & varchar(200) & 400 & & \\
& first\_name & varchar(50) & 100 & & \\
& middle\_name & varchar(50) & 100 & & \\
& last\_name & varchar(50) & 100 & & \\
& phone\_number & varchar(10) & 20 & & \\
\hline

\multirow{5}{*}{dishes}  & id & integer & 4 & \multirow{5}{*}{106} & \multirow{5}{*}{57344} & \multirow{5}{*}{0.05}\\
& weight & double & 8 & & \\
& colorfulness & double & 8 & & \\
& title & varchar(100) & 200 & & \\
& type & varchar(100) & 200 & & \\
\hline

\multirow{3}{*}{dishes\_ingredients} & id & integer & 4 & \multirow{3}{*}{534} & \multirow{3}{*}{81920} & \multirow{3}{*}{0.08}\\
& dish\_id & integer & 4 & & \\
& ingredient\_id & integer & 4 & & \\
\hline

\multirow{4}{*}{ingredients} & id & integer & 4 & \multirow{4}{*}{149} & \multirow{4}{*}{57344} & \multirow{4}{*}{0.05}\\
& title & varchar(100) & 200 & & \\
& type & varchar(100) & 200 & & \\
& cost & double & 8 & & \\
\hline

\multirow{4}{*}{dishes\_menus} & id & integer & 4 & \multirow{4}{*}{360} & \multirow{4}{*}{57344} & \multirow{4}{*}{0.05}\\
& dish\_id & integer & 4 & & \\
& menu\_id & integer & 4 & & \\
& date & date & 4 & & \\
\hline

\multirow{5}{*}{menus} & id & integer & 4 & \multirow{5}{*}{3} & \multirow{5}{*}{24576} & \multirow{5}{*}{0.02}\\
& title & varchar(100) & 200 & & \\
& cost & double & 8 & & \\
& count\_dishes & integer & 4 & & \\
& colorfulness & double & 8 & & \\
\hline



\end{tabular}
\end{adjustbox}

```

\newpage

```{=latex}
\begin{adjustbox}{max width=.99\linewidth}
\begin{tabular}{|c|l|l|c|c|c|c|}
\hline
\textbf{Отношение} & \textbf{Атрибут} & \textbf{Тип данных} & \textbf{Размер, байт} & \textbf{Среднее количество} & \textbf{Объем, байт} & \textbf{Объём, МБ} \\
\hline
\multirow{3}{*}{ingredients\_suppliers} & id & integer & 4 & \multirow{3}{*}{408} & \multirow{3}{*}{81920} & \multirow{3}{*}{0.08}\\
& ingredient\_id & integer & 4 & & \\
& supplier\_id & integer & 4 & & \\
\hline

\multirow{3}{*}{suppliers} & id & integer & 4 & \multirow{3}{*}{20} & \multirow{3}{*}{24576} & \multirow{3}{*}{0.02}\\
& title & varchar(100) & 200 & & \\
& productivity & double & 8 & & \\
\hline

\multirow{4}{*}{payment\_infos} & id & integer & 4 & \multirow{4}{*}{19936} & \multirow{4}{*}{1638400} & \multirow{4}{*}{1.56}\\
& user\_id & integer & 4 & & \\
& payment\_method\_id & integer & 4 & & \\
& requisites & varchar(100) & 200 & & \\
\hline

\multirow{3}{*}{payment\_methods} & id & integer & 4 & \multirow{3}{*}{4} & \multirow{3}{*}{24576} & \multirow{3}{*}{0.02}\\
& title & varchar(100) & 200 & & \\
& require\_requisites & boolean & 1 & & \\
\hline

\multirow{2}{*}{preferences\_categories} & id & integer & 4 & \multirow{2}{*}{5} & \multirow{2}{*}{24576} & \multirow{2}{*}{0.02}\\
& title & varchar(100) & 200 & & \\
\hline

\multirow{5}{*}{couriers} & id & integer & 4 & \multirow{5}{*}{100} & \multirow{5}{*}{57344} & \multirow{5}{*}{0.05}\\
& first\_name & varchar(50) & 100 & & \\
& middle\_name & varchar(50) & 100 & & \\
& last\_name & varchar(50) & 100 & & \\
& birth\_date & date & 4 & & \\
\hline

\multirow{3}{*}{preferences} & id & integer & 4 & \multirow{3}{*}{26} & \multirow{3}{*}{24576} & \multirow{3}{*}{0.02}\\
& title & varchar(100) & 200 & & \\
& preference\_category\_id & integer & 4 & & \\
\hline

\multirow{3}{*}{ingredients\_preferences} & id & integer & 4 & \multirow{3}{*}{86} & \multirow{3}{*}{24576} & \multirow{3}{*}{0.02}\\
& ingredient\_id & integer & 4 & & \\
& preference\_id & integer & 4 & & \\
\hline

\multirow{7}{*}{orders} & id & integer & 4 & \multirow{7}{*}{50000} & \multirow{7}{*}{4587520} & \multirow{7}{*}{4.38}\\
& user\_id & integer & 4 & & \\
& courier\_id & integer & 4 & & \\
& payment\_info\_id & integer & 4 & & \\
& menu\_id & integer & 4 & & \\
& created\_at & timestamp & 8 & & \\
& status & order\_status & 4 & & \\
\hline

\multirow{3}{*}{preferences\_users} & id & integer & 4 & \multirow{3}{*}{9051} & \multirow{3}{*}{655360} & \multirow{3}{*}{0.62}\\
& user\_id & integer & 4 & & \\
& preference\_id & integer & 4 & & \\
\hline

\end{tabular}
\end{adjustbox}
```